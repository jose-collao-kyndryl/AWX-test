---
# PLAY 1: Inicialización (Esta parte está perfecta)
- name: "Reporte: Creación de variables globales"
  hosts: localhost
  gather_facts: false
  tasks:
    - name: "REPORTE: Inicializar listas de resultados"
      ansible.builtin.set_fact:
        hosts_exitosos: []
        hosts_fallidos: []

# PLAY 2: Ejecución Principal (Aquí aplicamos las correcciones)
- name: "Validar Pre-requisitos en Servidores Windows via Jumphost"
  hosts: servidores_windows_via_jump
  gather_facts: false
  serial: 1
  ignore_unreachable: true
  vars:
    puerto_base_tunel_local: 59850

  tasks:
    - name: "CÁLCULO DE PUERTO: Definir puerto dinámico para {{ inventory_hostname }}"
      ansible.builtin.set_fact:
        puerto_dinamico_tunel: "{{ puerto_base_tunel_local | int + ansible_play_hosts_all.index(inventory_hostname) | int }}"
        
    - name: "Establecer ansible_port para {{ inventory_hostname }}"
      ansible.builtin.set_fact:
        ansible_port: "{{ puerto_dinamico_tunel }}"
        
    - name: "PROCESO PRINCIPAL Y LIMPIEZA PARA {{ inventory_hostname }}"
      block:
        - name: "TUNNEL: Estableciendo túnel SSH en background"
          # ... (resto de las tareas del túnel y validación se mantienen igual)
          ansible.builtin.command: >
            ssh -f -N -L {{ puerto_dinamico_tunel }}:{{ target_actual_ip }}:{{ target_actual_winrm_port }}
            -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ExitOnForwardFailure=yes
            -o ServerAliveInterval=60 -o ConnectTimeout=15
            {{ jumphost_user }}@{{ jumphost_ip }}
          delegate_to: localhost
          changed_when: false

        - name: "TUNNEL: Esperar a que el puerto local {{ puerto_dinamico_tunel }} esté activo"
          ansible.builtin.wait_for:
            host: 127.0.0.1
            port: "{{ puerto_dinamico_tunel }}"
            timeout: 20
            delay: 2
            state: started
          delegate_to: localhost

        - name: "VALIDACIÓN WINDOWS: Conectividad WinRM y ejecución de 'hostname'"
          ansible.windows.win_command: hostname
          register: windows_hostname_validation
          changed_when: false

        - name: "Registrar host exitoso"
          delegate_to: localhost
          # <--- CORRECCIÓN 1: Se eliminó 'run_once: true'
          ansible.builtin.set_fact:
            # <--- CORRECCIÓN 2: Se usa 'hostvars.localhost.hosts_exitosos'
            hosts_exitosos: "{{ hostvars.localhost.hosts_exitosos + [{'host': inventory_hostname, 'ip': target_actual_ip, 'hostname_remoto': windows_hostname_validation.stdout_lines[0]}] }}"
            
      rescue:
        - name: "Registrar host fallido"
          delegate_to: localhost
          # <--- CORRECCIÓN 1: Se eliminó 'run_once: true'
          ansible.builtin.set_fact:
            # <--- CORRECCIÓN 2: Se usa 'hostvars.localhost.hosts_fallidos'
            hosts_fallidos: "{{ hostvars.localhost.hosts_fallidos + [{'host': inventory_hostname, 'ip': target_actual_ip, 'error': ansible_failed_result.msg | default('Error desconocido al procesar el host.')}] }}"

      always:
        - name: "LIMPIEZA: Asegurando la terminación del túnel SSH"
          ansible.builtin.command: >
            pkill -f "ssh .* -L {{ puerto_dinamico_tunel }}:{{ target_actual_ip }}:{{ target_actual_winrm_port }}.*{{ jumphost_user }}@{{ jumphost_ip }}"
          delegate_to: localhost
          changed_when: false
          failed_when: false

# PLAY 3: Generación del Reporte (Esta parte está perfecta)
- name: "Reporte - generando artefacto FINAL"
  hosts: localhost
  gather_facts: false
  tasks:
    - name: "REPORTE FINAL: Generar artefacto con el resumen"
      ansible.builtin.set_stats:
        data:
          resumen_validacion:
            hosts_exitosos_total: "{{ hosts_exitosos | length }}"
            hosts_fallidos_total: "{{ hosts_fallidos | length }}"
            hosts_exitosos: "{{ hosts_exitosos }}"
            hosts_fallidos: "{{ hosts_fallidos }}"
